Велиметов Юсуп Касумович, лабораторная работа 3, вариант 4.
Программа состоит из нескольких модулей-файлов:
1) main.asm - точка входа, здесь описана функция _start
2) get_valid_num.asm - функция ввода валидного значения числа с предварительным указанием отрезка [edge1,edge2]!!!! edge2>=edge1
3) calculate.asm - здесь описана функция calculate, которая считывает значение по формуле (вариант 4) без математического сопроцессора и сохраняет их в глобальные переменные
4) print_rax.asm - функции для вывода результатов: для печати в консоль числа в регистре RAX
5) print.asm - упрощеная функция printf() стандартной библиотеки Си. 
При потытке вывести текст на консоль столкнулся с проблемой: текст буферизировался и выводился в самом конце, то есть после всех запросов на ввод.
Мне необходимо было в программе произвести последовательный ввод данных. 
На самом деле проблема решалась использованием функции fflash(). Но мной было принято решение в учебных целях сотворить велосипед.
Функция принимает в ка один аргумент (адрес) и печатает все посимвольно с переданного адреса до терминального символа '\0'
6) makefile

На этапе ввода данных осуществляется контроль: 
- ввод только целых числел
- ввод чисел из отрезка [edge1,edge2]!!!! edge2>=edge1
- исключение деления на ноль.
Запуск программы осуществляется на Linux (процессор x64 intel):
./main 
Оценка полученных результатов:
Во всех тестовых запусках программы получал результат с точностью до единиц, как на СИ, так и на асемблере. 
Для расчетов и хранения данных в процессоре использовал 64 битные регистры. Это позволило написать единый код как для int16_t так и для uint16_t переменных
Аномальный результат можно получить если буду перемножаться int16_t и uint16_t  в краиних значениях. 
Данная ситуания преведет к переполнению 32-битной переменной RESULT  и скажению результата. 
Решить проблему можно, используя 64-битную переменную RESULT

